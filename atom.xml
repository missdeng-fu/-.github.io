<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星余</title>
  
  
  <link href="https://www.imalun.com/atom.xml" rel="self"/>
  
  <link href="https://www.imalun.com/"/>
  <updated>2024-01-14T04:04:59.826Z</updated>
  <id>https://www.imalun.com/</id>
  
  <author>
    <name>日生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>健身动作之-练肩篇</title>
    <link href="https://www.imalun.com/2024/01/14/1.14/"/>
    <id>https://www.imalun.com/2024/01/14/1.14/</id>
    <published>2024-01-14T03:47:16.359Z</published>
    <updated>2024-01-14T04:04:59.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动作篇"><a href="#动作篇" class="headerlink" title="动作篇"></a>动作篇</h1><h2 id="第一个动作—-哑铃推举"><a href="#第一个动作—-哑铃推举" class="headerlink" title="第一个动作—-哑铃推举"></a>第一个动作—-哑铃推举</h2><p>哑铃推举的时候，小臂是始终垂直于地面的，推的时候，想象把哑铃往正上方推，推的时候，两个哑铃是微微八字，放的时候，放到耳朵两侧就可以，推的时候再往上推，发力，手臂不要完全打直，只要肩膀收紧就可以，这个时候，前束最受力，从侧面看，肘关节要微微在肩膀的前侧，这样肩关节的压力还是最小，推的时候，从侧面看，小臂始终垂直于地面，坐在凳子上推荐的时候，屁股可以微微往前去一点（也就是往前做一点），去五公分左右，然后背部贴近凳子，做四组，每组12次，组间休息休息到50秒到一分钟都可以。</p><h2 id="第二个动作—–哑铃侧平举"><a href="#第二个动作—–哑铃侧平举" class="headerlink" title="第二个动作—–哑铃侧平举"></a>第二个动作—–哑铃侧平举</h2><p>首先我们拿到哑铃之后，要把哑铃放到大腿前侧，然后沉肩，什么是沉肩，就是耸肩的反义词，沉肩，固定住斜方肌，然后中束发力，记住做的过程中，尽量也不要缩脖子去做，始终往下压着肩，从正面看，肩最高，肘第二，手第三的高度关系不要错，手腕保持中立位置，也不要往下掉，也不用往上飞，中立位就可以，肘在肩膀的前侧，这样去做。每组十二次，做四组</p><h2 id="第三个动作——哑铃俯身飞鸟"><a href="#第三个动作——哑铃俯身飞鸟" class="headerlink" title="第三个动作——哑铃俯身飞鸟"></a>第三个动作——哑铃俯身飞鸟</h2><p>做这个动作，有一个点就很重要，就是要控制住肩胛骨，推出去含胸，是肩胛骨打开的一个状态，咱们做哑铃俯身飞鸟的时候，，就要保持肩胛骨始终打开的这样一个状态，这样才能更好的刺激我们的这个后束，咱们首先要找到一个凳子，屁股尽量往前坐，腿部下面留有足够的空间，然后俯身，肩胛骨打开，保持打开这样的一个固定的角度，一直打开，然后后束发力，把哑铃完全收紧，手臂不要完全打直，微曲，每组12次，每次做四组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动作篇&quot;&gt;&lt;a href=&quot;#动作篇&quot; class=&quot;headerlink&quot; title=&quot;动作篇&quot;&gt;&lt;/a&gt;动作篇&lt;/h1&gt;&lt;h2 id=&quot;第一个动作—-哑铃推举&quot;&gt;&lt;a href=&quot;#第一个动作—-哑铃推举&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="健身" scheme="https://www.imalun.com/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>健身动作之-练背篇</title>
    <link href="https://www.imalun.com/2024/01/12/1.12/"/>
    <id>https://www.imalun.com/2024/01/12/1.12/</id>
    <published>2024-01-12T04:31:45.669Z</published>
    <updated>2024-01-12T05:19:38.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热身篇"><a href="#热身篇" class="headerlink" title="热身篇"></a>热身篇</h1><p>开肩—-两只手扶着一个杠俯身打开肩胛骨，同时也能适当拉伸一下背阔肌–压十秒钟左右就好</p><h1 id="练背篇"><a href="#练背篇" class="headerlink" title="练背篇"></a>练背篇</h1><h2 id="第一个动作—高位下拉"><a href="#第一个动作—高位下拉" class="headerlink" title="第一个动作—高位下拉"></a>第一个动作—高位下拉</h2><p>首先稳定住自己的下半身，腿卡住，卡紧，完全卡死，然后把肩胛骨往上送，背阔肌拉长，收的时候，肩胛骨下沉，然后拉的时候，把杠拉到自己的锁骨上面。肩胛骨收住</p><p>两个注意点：<br>第一：往下拉的时候，拉到锁骨上方<br>第二：肩胛骨往上放的时候，一定要完全放上去，背阔肌充分拉伸，然后拉的时候，尽量往下夹住，夹到最紧，让行程达到最大化<br>第三：做这个动作可以往后仰，但不能往后太多，微微向后仰一点，收紧就ok<br>第四：因为这是第一个动作，所以我们组数可以做多一点，一般会做到六组，然后重量采用依次递增，这样既能热身，又能激活自己的肌肉，重量可以从四片开始，然后两片两片的加，一直加到第六组，如果加到后面重量加不动了，那就用这个固定的重量一直做到第六组就结束</p><h2 id="第二个动作—坐姿划船"><a href="#第二个动作—坐姿划船" class="headerlink" title="第二个动作—坐姿划船"></a>第二个动作—坐姿划船</h2><p>首先固定好自己的下半身，然后腰部挺直，往前送，把肩胛骨打开送出去，收的时候挺胸，把把手拉到自己的肚子上面，夹肘，肘夹紧挺胸，肩胛骨使劲往后夹收住，这就是顶峰的动作，有一个短暂的停顿0.5s，放身体微前倾，打开肩胛骨收夹肘</p><p>特点：首先要把肩胛骨送出去，让行程达到最大化，然后收的时候就紧贴着身体往后收，夹住，把杠拉到自己肚子上面挺胸，这样背阔肌、大圆肌才能完全收住，这个动作我们需要做四组，然后采用固定重量，次数在八到十二次之间</p><h2 id="第三个动作—-直臂下压"><a href="#第三个动作—-直臂下压" class="headerlink" title="第三个动作—-直臂下压"></a>第三个动作—-直臂下压</h2><p>这个动作也是练背阔肌，大小圆肌的一个动作，首先，身体往后站一点，身体前倾固定住，然后手臂和身体，呈一条直线，尽量拉长自己的背阔肌，收的时候，想象一个画弧的过程，收的时候，前三分之二的路程是直臂，最后曲臂收紧，把杠拉到自己腰带的位置，最后有一个夹背的动作，肩胛骨往后收，肘往后夹</p><p>注意：<br>因为这个动作比较轻松，所以每组需要做12-15次之间</p><h2 id="第四个动作—窄距高位下拉"><a href="#第四个动作—窄距高位下拉" class="headerlink" title="第四个动作—窄距高位下拉"></a>第四个动作—窄距高位下拉</h2><p>首先夹住把手的近端，也就是离你近的这一端，然后肩胛骨往上送，把背阔肌完全拉长，身体微微向后仰挺胸，然后把手拉到自己的胸前，这个时候，腰是一个微微反弓的状态，送上去，这个动作我们选择固定重量，做四组，每组12次就可以</p><h2 id="第五个动作—杠铃俯身划船"><a href="#第五个动作—杠铃俯身划船" class="headerlink" title="第五个动作—杠铃俯身划船"></a>第五个动作—杠铃俯身划船</h2><p>这个动作，也是我们练背当中必不可少的一个动作，首先，俯身屈膝，腰挺直，把力施加在腿后侧链上，减少腰部压力，肩胛骨下沉，把杠铃放出去，收的时候，杠顺着自己大腿的方向，平行往后，夹肘，收肩胛骨，这个杠铃划船我们采用固定的重量，做五组，每组要做到十二次</p><h2 id="第六个动作—宽距坐姿划船"><a href="#第六个动作—宽距坐姿划船" class="headerlink" title="第六个动作—宽距坐姿划船"></a>第六个动作—宽距坐姿划船</h2><p>这个动作，是锻炼我们比较薄弱的中上背<br>注意点：<br>第一：是宽距的，可以用高位下拉的把手<br>第二：拉的时候，拉到胸部的位置，普通的坐姿划船是拉到肚子这里，这个动作就不需要刻意去夹肘了<br>第三：还是腰注意的是，把肩胛骨完全的送到前面，然后收的时候挺胸，肩胛骨使劲向后夹，这样完全夹住，这样才能最大程度的刺激到我们的中背部，这个动作，采用固定的重量，因为重量比较小，所以每组要做到十五次，做四组就结束了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这六个动作，要在90分钟内做完，然后小白组间休息可以到一分钟，新手练背会遇到很多困难，因为手臂借力或者前臂借力等，给新手的建议是，不要依赖助力带</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热身篇&quot;&gt;&lt;a href=&quot;#热身篇&quot; class=&quot;headerlink&quot; title=&quot;热身篇&quot;&gt;&lt;/a&gt;热身篇&lt;/h1&gt;&lt;p&gt;开肩—-两只手扶着一个杠俯身打开肩胛骨，同时也能适当拉伸一下背阔肌–压十秒钟左右就好&lt;/p&gt;
&lt;h1 id=&quot;练背篇&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="健身" scheme="https://www.imalun.com/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>健身动作之-练胸篇</title>
    <link href="https://www.imalun.com/2024/01/11/1.11/"/>
    <id>https://www.imalun.com/2024/01/11/1.11/</id>
    <published>2024-01-11T02:53:25.999Z</published>
    <updated>2024-01-12T04:32:15.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热身篇"><a href="#热身篇" class="headerlink" title="热身篇"></a>热身篇</h1><h2 id="第一个动作"><a href="#第一个动作" class="headerlink" title="第一个动作"></a>第一个动作</h2><p>大臂水平保持不动，小臂往后摆甩–经典招财猫动作–20次为一组，一次一组，可以速度快一点，幅度大一点</p><h2 id="第二个动作"><a href="#第二个动作" class="headerlink" title="第二个动作"></a>第二个动作</h2><p>大臂夹紧身体，小臂往外，往外甩，幅度大一点—20次为一组，一次一组</p><h2 id="第三个动作"><a href="#第三个动作" class="headerlink" title="第三个动作"></a>第三个动作</h2><p>手臂长大点，向前画圆，抡的越圆越大越好—-20圈为一组，一次一组</p><h2 id="第四个动作"><a href="#第四个动作" class="headerlink" title="第四个动作"></a>第四个动作</h2><p>手臂长大点，向后画圆，抡的越圆越大越好—-20圈为一组，一次一组</p><h1 id="练胸篇"><a href="#练胸篇" class="headerlink" title="练胸篇"></a>练胸篇</h1><h2 id="第一个动作—-杠铃平板卧推–黄金动作"><a href="#第一个动作—-杠铃平板卧推–黄金动作" class="headerlink" title="第一个动作—-杠铃平板卧推–黄金动作"></a>第一个动作—-杠铃平板卧推–黄金动作</h2><p>首先，你要找你的眼睛和这个杠的位置，你的眼睛要在这个杠的正下方</p><p>脚微微的往里面收一点，身体成一个反弓的姿态</p><h3 id="如何调整握距"><a href="#如何调整握距" class="headerlink" title="如何调整握距"></a>如何调整握距</h3><p>首先你要保持自己握对称，然后起杠之后，先往下放，放到杠铃触胸的时候，看看小臂是否和杠垂直（这样很重要）</p><h3 id="如何调整手腕"><a href="#如何调整手腕" class="headerlink" title="如何调整手腕"></a>如何调整手腕</h3><p>采用全握，自由重量一定要采用全握，大拇指扣紧，让杠的重量，压在小臂的延长线上</p><h3 id="推举的方式"><a href="#推举的方式" class="headerlink" title="推举的方式"></a>推举的方式</h3><p>杠铃往下放的的时候，放到乳头，上下一两公分的位置都可以，从侧面靠，小臂始终垂直于地面</p><h3 id="身体动作"><a href="#身体动作" class="headerlink" title="身体动作"></a>身体动作</h3><p>推的时候，收紧肩胛骨，肩胛骨微往后夹一点点，肩膀下沉，挺胸，推的时候，手臂不要完全打直，微曲，胸部收紧就可以，放的时候匀速往下放，杠铃的轨迹，你就想象成推的直上直下，大臂和身体的夹角大约是四十五度</p><h3 id="呼吸"><a href="#呼吸" class="headerlink" title="呼吸"></a>呼吸</h3><p>杠下来的时候吸气，发力的时候，吐出去</p><h2 id="第二个动作—蝴蝶机夹胸"><a href="#第二个动作—蝴蝶机夹胸" class="headerlink" title="第二个动作—蝴蝶机夹胸"></a>第二个动作—蝴蝶机夹胸</h2><h3 id="位置调整"><a href="#位置调整" class="headerlink" title="位置调整"></a>位置调整</h3><p>要让你的肩，高于你的手，一拳左右的距离</p><h3 id="身体部位"><a href="#身体部位" class="headerlink" title="身体部位"></a>身体部位</h3><p>手臂全程打直，手臂内侧相对，胸部收紧，肩膀不要往前，肩胛骨微微向后。手臂微曲，始终感觉是挺胸的状态去做，肘向后的时候，手臂不要打太直，发力的时候，手打直，下去的时候手弯曲，也是做4组，每组12次</p><h3 id="第三个动作—哑铃上斜卧推"><a href="#第三个动作—哑铃上斜卧推" class="headerlink" title="第三个动作—哑铃上斜卧推"></a>第三个动作—哑铃上斜卧推</h3><p>肩胛骨向后微微缩紧，手臂打直，将哑铃举起，哑铃微微成八字，往下放，放到胸部两侧，这个时候，大臂和身体，大约是一个45度的角度，垂直往上发力，做四组，每组12次</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热身篇&quot;&gt;&lt;a href=&quot;#热身篇&quot; class=&quot;headerlink&quot; title=&quot;热身篇&quot;&gt;&lt;/a&gt;热身篇&lt;/h1&gt;&lt;h2 id=&quot;第一个动作&quot;&gt;&lt;a href=&quot;#第一个动作&quot; class=&quot;headerlink&quot; title=&quot;第一个动作&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="健身" scheme="https://www.imalun.com/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>2023年终总结</title>
    <link href="https://www.imalun.com/2024/01/01/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://www.imalun.com/2024/01/01/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-01-01T05:40:19.412Z</published>
    <updated>2024-01-01T06:09:57.641Z</updated>
    
    <content type="html"><![CDATA[<p>2023年过的真快，好像去年跨年还在昨天，今天就已经是2024年了，我对2023年做个总结，2023的关键词是失败</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>2023年的生活过的一塌糊涂，从新年的第一天就一直吵架，3月复试失败，4月到六月感情不顺，六月分手到如今，患上了抑郁症，还困在感情里走不出来，至今还在疗伤，2023过的一团糟糕，对于2023年，我对自己的忠告的是，以后做什么决定，一定不要头脑一热就去做，要仔细想，反复想，关于生活的选择，有可能从一开始就决定了一项重大事情的失败，我时常会想，假如当时我选择了向父母要钱，而不是去工作，我和陶俊余，会走到今天这步吗，我想好的心态真的决定了最终问题的走向，所以以后在生活的选择上，一定要好好想，站在十年之后想，十年之后，你会希望自己怎么做，做出怎样的选择，拥有怎么样的人生体验</p><h1 id="事业"><a href="#事业" class="headerlink" title="事业"></a>事业</h1><p>事业坎坎坷坷，复试失败后，居然调剂到了中石油，这辈子没想过来北方，只能说，也许一切冥冥之中自有安排。</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>不要浪费时间，把时间花费在学习，健身，看书上，珍惜人生的每一缕光阴</p><h1 id="长相"><a href="#长相" class="headerlink" title="长相"></a>长相</h1><p>2023的气质变化真的巨大，具体见下图</p><div class="image-container"><img src="https://bu.dusays.com/2024/01/01/65924f2a38843.jpg"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> <img src="https://bu.dusays.com/2024/01/01/65924acc959d5.jpg"  alt="十二月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'>  </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年过的真快，好像去年跨年还在昨天，今天就已经是2024年了，我对2023年做个总结，2023的关键词是失败&lt;/p&gt;
&lt;h1 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h1&gt;&lt;p&gt;2023年</summary>
      
    
    
    
    <category term="年终总结" scheme="https://www.imalun.com/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>新年祝福</title>
    <link href="https://www.imalun.com/2023/12/30/test/"/>
    <id>https://www.imalun.com/2023/12/30/test/</id>
    <published>2023-12-30T11:42:50.000Z</published>
    <updated>2023-12-31T15:17:48.638Z</updated>
    
    <content type="html"><![CDATA[<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"video":{"url":"/video/祝福.mp4"},"danmaku":{"id":"someid","api":"https://api.prprpr.me/dplayer/","addition":["/some.json"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on("loadstart",function(){console.log("loadstart")})})()</script> ]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;dplayer0&quot; class=&quot;dplayer hexo-tag-dplayer-mark&quot; style=&quot;margin-bottom: 20px;&quot;&gt;&lt;/div&gt;&lt;script&gt;(function(){var player = new DPlayer({&quot;c</summary>
      
    
    
    
    <category term="视频记录" scheme="https://www.imalun.com/categories/%E8%A7%86%E9%A2%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础课-数据结构</title>
    <link href="https://www.imalun.com/2023/12/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://www.imalun.com/2023/12/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-12-28T12:53:59.227Z</published>
    <updated>2023-12-28T16:15:28.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法基础课"><a href="#算法基础课" class="headerlink" title="算法基础课"></a>算法基础课</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="C:\Users\HP\Desktop\加速比图片.png" alt="加速比图片" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre><code class="hljs C++">=<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-comment">/*这个题的理解上有一个问题困扰了我很久，就是这个Idx究竟代表什么，翻了很多的评论，我觉得以下这个评论</span><span class="hljs-comment">我觉得很合适说说的我个人对idx的理解</span><span class="hljs-comment">先区分两个概念：</span><span class="hljs-comment">节点和结点</span><span class="hljs-comment">节点：一个点</span><span class="hljs-comment">结点：链表的元素，含e[idx],ne[idx]两个部分</span><span class="hljs-comment">e[idx]:结点编号为idx对应的节点值</span><span class="hljs-comment">ne[idx]：结点编号为idx对应的下一个结点的编号</span><span class="hljs-comment">区分完这两个概念应该能理解idx的作用，为结点编号</span><span class="hljs-comment">我觉得看完这个之后，应该就能很好的理解这个代码</span><span class="hljs-comment">*/</span><span class="hljs-comment">// head 表示头结点的下标</span><span class="hljs-comment">// e[i] 表示节点i的值</span><span class="hljs-comment">// ne[i] 表示节点i的next指针是多少</span><span class="hljs-comment">// idx 存储当前已经用到了哪个点</span><span class="hljs-type">int</span> head, e[N], ne[N], idx;<span class="hljs-comment">// 初始化</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    head = <span class="hljs-number">-1</span>;    idx = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 将x插到头结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    e[idx] = x, ne[idx] = head, head = idx ++ ;&#125;<span class="hljs-comment">// 将x插到下标是k的点后面</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;&#125;<span class="hljs-comment">// 将下标是k的点后面的点删掉</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><span class="hljs-function"></span>&#123;    ne[k] = ne[ne[k]];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> m;    cin &gt;&gt; m;    <span class="hljs-built_in">init</span>();    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-type">int</span> k, x;        <span class="hljs-type">char</span> op;        cin &gt;&gt; op;        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;H&#x27;</span>)        &#123;            cin &gt;&gt; x;            <span class="hljs-built_in">add_to_head</span>(x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;D&#x27;</span>)        &#123;            cin &gt;&gt; k;            <span class="hljs-keyword">if</span> (!k) head = ne[head];            <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(k - <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span>        &#123;            cin &gt;&gt; k &gt;&gt; x;            <span class="hljs-built_in">add</span>(k - <span class="hljs-number">1</span>, x);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">这个题目，初始的时候我看的有点懵逼，在这个模板里，加了两个哑巴结点，这样就能够减少操作，实际上0和1这个结点一直不会被删除，是一个很好的做法</span><span class="hljs-comment">*/</span><span class="hljs-type">int</span> m;<span class="hljs-type">int</span> e[N], l[N], r[N], idx;<span class="hljs-comment">// 在节点a的右边插入一个数x</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    e[idx] = x;    l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx ++ ;&#125;<span class="hljs-comment">// 删除节点a</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><span class="hljs-function"></span>&#123;    l[r[a]] = l[a];    r[l[a]] = r[a];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; m;    <span class="hljs-comment">// 0是左端点，1是右端点</span>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    idx = <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (m -- )    &#123;        string op;        cin &gt;&gt; op;        <span class="hljs-type">int</span> k, x;        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;L&quot;</span>)        &#123;            cin &gt;&gt; x;            <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;R&quot;</span>)        &#123;            cin &gt;&gt; x;            <span class="hljs-built_in">insert</span>(l[<span class="hljs-number">1</span>], x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>)        &#123;            cin &gt;&gt; k;            <span class="hljs-built_in">remove</span>(k + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;IL&quot;</span>)        &#123;            cin &gt;&gt; k &gt;&gt; x;            <span class="hljs-built_in">insert</span>(l[k + <span class="hljs-number">1</span>], x);        &#125;        <span class="hljs-keyword">else</span>        &#123;            cin &gt;&gt; k &gt;&gt; x;            <span class="hljs-built_in">insert</span>(k + <span class="hljs-number">1</span>, x);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//输出的时候也是从r[0]输出，没有输出哑巴结点</span>    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> st[N];<span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> n;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span>(n--)    &#123;        string s;        cin &gt;&gt; s;        <span class="hljs-comment">//栈顶所在索引往后移动一格，然后放入x。</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)        &#123;            <span class="hljs-type">int</span> a;            cin &gt;&gt; a;            st[++top] = a;        &#125;        <span class="hljs-comment">//往前移动一格</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)        &#123;            top --;        &#125;        <span class="hljs-comment">//返回栈顶元素</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)        &#123;            cout &lt;&lt; st[top] &lt;&lt; endl;        &#125;        <span class="hljs-comment">//大于等于 0 栈非空，小于 0 栈空</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)        &#123;            cout &lt;&lt; (top == <span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;        &#125;    &#125;&#125;</code></pre><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;stack&lt;<span class="hljs-type">int</span>&gt; num;stack&lt;<span class="hljs-type">char</span>&gt; op;<span class="hljs-comment">//优先级表</span>unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; h&#123; &#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125; &#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span><span class="hljs-comment">//求值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> a = num.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//第二个操作数</span>    num.<span class="hljs-built_in">pop</span>();    <span class="hljs-type">int</span> b = num.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//第一个操作数</span>    num.<span class="hljs-built_in">pop</span>();    <span class="hljs-type">char</span> p = op.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//运算符</span>    op.<span class="hljs-built_in">pop</span>();    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-comment">//结果 </span>    <span class="hljs-comment">//计算结果</span>    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;+&#x27;</span>) r = b + a;    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;-&#x27;</span>) r = b - a;    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;*&#x27;</span>) r = b * a;    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;/&#x27;</span>) r = b / a;    num.<span class="hljs-built_in">push</span>(r);<span class="hljs-comment">//结果入栈</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string s;<span class="hljs-comment">//读入表达式</span>    cin &gt;&gt; s;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i]))<span class="hljs-comment">//数字入栈</span>        &#123;            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, j = i;<span class="hljs-comment">//计算数字</span>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[j]))            &#123;                x = x * <span class="hljs-number">10</span> + s[j] - <span class="hljs-string">&#x27;0&#x27;</span>;                j++;            &#125;            <span class="hljs-comment">//这个地方的理解可以看看海绵宝宝题解的第一条评论，写的很好</span>            num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//数字入栈</span>            i = j - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//左括号无优先级，直接入栈</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-comment">//左括号入栈</span>        &#123;            op.<span class="hljs-built_in">push</span>(s[i]);        &#125;        <span class="hljs-comment">//括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-comment">//右括号</span>        &#123;            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-comment">//一直计算到左括号</span>                <span class="hljs-built_in">eval</span>();            op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//左括号出栈</span>        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>() &amp;&amp; h[op.<span class="hljs-built_in">top</span>()] &gt;= h[s[i]])<span class="hljs-comment">//待入栈运算符优先级低，则先计算</span>                <span class="hljs-built_in">eval</span>();            op.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//操作符入栈</span>        &#125;    &#125;    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">//剩余的进行计算</span>    cout &lt;&lt; num.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<span class="hljs-comment">//输出结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> q[N];<span class="hljs-comment">//[hh, tt] 之间为队列（左闭右闭）</span><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>;<span class="hljs-comment">//队头位置</span><span class="hljs-type">int</span> tt = <span class="hljs-number">-1</span>;<span class="hljs-comment">//队尾位置</span><span class="hljs-comment">//操作次数</span><span class="hljs-type">int</span> m;<span class="hljs-comment">//操作方式</span>string s;<span class="hljs-comment">//入队：队尾先往后移动一格，再放入要插入的数据</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    q[++tt] = x;&#125;<span class="hljs-comment">//出队：队头往后移动一格</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;    hh++;&#125;<span class="hljs-comment">//[hh, tt]表示队列区间，当tt &gt;= hh时，区间不为空</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span>(tt &gt;= hh) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;&#125; <span class="hljs-comment">//hh指向队头，q[hh]代表队头元素</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span> <span class="hljs-params">()</span></span>&#123;    cout &lt;&lt; q[hh] &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; m;    <span class="hljs-keyword">while</span>(m--)&#123;        cin &gt;&gt; s;        <span class="hljs-comment">//入队</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;            <span class="hljs-type">int</span> x;            cin &gt;&gt; x;            <span class="hljs-built_in">push</span>(x);        &#125;        <span class="hljs-comment">//出队</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;            <span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-comment">//问空</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;            <span class="hljs-built_in">empty</span>();        &#125;        <span class="hljs-comment">//问队头</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;            <span class="hljs-built_in">query</span>();        &#125;    &#125;&#125;</code></pre><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> stk[N], tt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">int</span> x;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);        <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;        <span class="hljs-keyword">if</span> (!tt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 &quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, stk[tt]);        stk[ ++ tt] = x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000100</span>;<span class="hljs-comment">//这段代码中很关键的点在于，q[N]中存的是数组下标，而不是数组元素</span><span class="hljs-comment">//单调队列一般用双端队列保证其单调性</span><span class="hljs-type">int</span> a[N], q[N], n, k;<span class="hljs-comment">//队头和队尾，在队尾插入，队头获取</span><span class="hljs-type">int</span> front = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);    <span class="hljs-comment">//先找每个窗口的最小值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-comment">//如果当前队头在数组的下标小于当前窗口的最小下标，这个窗口就不包含这个元素了那么无论如何都要剔除队头这个元素</span>        <span class="hljs-comment">//所以要在队头删除这个元素</span>        <span class="hljs-keyword">if</span> (front &lt;= tail &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[front]) front++;        <span class="hljs-comment">//保证单调性，在队尾删除（为什么要在队尾删除，简单来说在队头删除不能保证单调</span>        <span class="hljs-comment">//比如-3 5为当前队列，当前的元素为3，如果在队头操作，那么按照a[i] &lt;= a[q[front]，有3 &gt; -3，因此不做删除操作</span>        <span class="hljs-comment">//但是接下来就出现问题了，3就要入队了。此时队列就是-3 5 3，不符合单调性了！</span>        <span class="hljs-comment">//但如果在队尾操作，按照a[i] &lt;= a[q[tail]，有3 &lt; 5，就要让5出队</span>        <span class="hljs-comment">//之后3入队，队列就是-3 3，满足单调性</span>        <span class="hljs-keyword">while</span> (front &lt;= tail &amp;&amp; a[i] &lt;= a[q[tail]]) tail--;        q[++tail] = i;        <span class="hljs-comment">//队头为窗口的最小值</span>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[front]]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-comment">//这次找最大值，同理</span>    front = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (front &lt;= tail &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[front]) front++;        <span class="hljs-keyword">while</span> (front &lt;= tail &amp;&amp; a[i] &gt;= a[q[tail]]) tail--;        q[++tail] = i;        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[front]]);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法基础课&quot;&gt;&lt;a href=&quot;#算法基础课&quot; class=&quot;headerlink&quot; title=&quot;算法基础课&quot;&gt;&lt;/a&gt;算法基础课&lt;/h1&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;</summary>
      
    
    
    
    <category term="算法基础课" scheme="https://www.imalun.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>今日学习记录</title>
    <link href="https://www.imalun.com/2023/12/27/11-27/"/>
    <id>https://www.imalun.com/2023/12/27/11-27/</id>
    <published>2023-12-27T15:52:15.706Z</published>
    <updated>2023-12-27T15:52:30.928Z</updated>
    
    <content type="html"><![CDATA[<p>今天的perl语言看到了第三章，感觉基础概念过一下有个大概印象就好，真正提高代码能力还是得靠后期写项目，因此把书过一遍之后，就去找些项目需求来写，用来提高代码能力<br>shell语言今天把讲义看完了，我觉得学习得时间实在是很紧张，所以我觉得，以后先看讲义，讲义有看不懂的地方就看评论，然后做作业，作业中有不会得地方，再回去看视频，今天写了人生中得第一个脚本，虽然是一个很简单得不能再简单得脚本，可它也是个脚本，希望自己继续保持学习，再接再励，不要放弃</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的perl语言看到了第三章，感觉基础概念过一下有个大概印象就好，真正提高代码能力还是得靠后期写项目，因此把书过一遍之后，就去找些项目需求来写，用来提高代码能力&lt;br&gt;shell语言今天把讲义看完了，我觉得学习得时间实在是很紧张，所以我觉得，以后先看讲义，讲义有看不懂的地</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础课-基础算法</title>
    <link href="https://www.imalun.com/2023/12/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE(1)/"/>
    <id>https://www.imalun.com/2023/12/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE(1)/</id>
    <published>2023-12-26T05:10:10.506Z</published>
    <updated>2023-12-26T05:10:26.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板"><a href="#快速排序模板" class="headerlink" title="快速排序模板"></a>快速排序模板</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> q[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l&gt;=r)  <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>, x=q[l+r&gt;&gt;<span class="hljs-number">1</span>];    <span class="hljs-keyword">while</span>(i&lt;j)    &#123;        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i]&lt;x);        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j]&gt;x);        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(q[i],q[j]);    &#125;    <span class="hljs-built_in">quick_sort</span>(q,l,j);    <span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><h3 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000010</span>;<span class="hljs-type">int</span> q[N],temp[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//递归的终止情况</span>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//第一步：分成子问题</span>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-comment">//第二步：递归处理子问题</span>    <span class="hljs-built_in">merge_sort</span>(q, l, mid ), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);    <span class="hljs-comment">//第三步：合并子问题</span>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>, tmp[r - l + <span class="hljs-number">1</span>];    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);    <span class="hljs-built_in">merge_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[j]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="二分模板"><a href="#二分模板" class="headerlink" title="二分模板"></a>二分模板</h3><pre><code class="hljs C++"><span class="hljs-comment">//写的 非常好的二分模板</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n,m,q[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-type">int</span> k;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);        <span class="hljs-comment">//寻找第一个等于K的坐标 我这边让二分的边界定为 左边为&lt;5 右边&gt;=5 则所求为r</span>        <span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=n;        <span class="hljs-keyword">while</span>(l+<span class="hljs-number">1</span>!=r)<span class="hljs-comment">//当l与r没有相接的时候,求边界</span>        &#123;            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-comment">//下面找第一个&gt;=5的坐标</span>            <span class="hljs-keyword">if</span>(q[mid]&gt;=k) r=mid;            <span class="hljs-keyword">else</span> l=mid;        &#125;        <span class="hljs-comment">//此时得到的r是第一个&gt;=5的坐标</span>        <span class="hljs-keyword">if</span>(q[r]!=k) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 -1\n&quot;</span>);        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,r);                <span class="hljs-comment">//现在找最后一个&lt;=5的数字 我这边让二分的左边为&lt;=5 右边为&gt;5 则所求为ll</span>                <span class="hljs-type">int</span> ll=<span class="hljs-number">-1</span>,rr=n;                <span class="hljs-keyword">while</span>(ll+<span class="hljs-number">1</span>!=rr)                &#123;                                        <span class="hljs-type">int</span> mid=ll+rr&gt;&gt;<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(q[mid]&lt;=k) ll=mid;                    <span class="hljs-keyword">else</span> rr=mid;                &#125;                <span class="hljs-keyword">if</span>(q[ll]!=k) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,r);                <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ll);            &#125;            &#125;    &#125;<span class="hljs-comment">//非常好的二分博客引用</span>https:<span class="hljs-comment">//blog.csdn.net/WJPnb1/article/details/126360962?spm=1001.2014.3001.5502</span></code></pre><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="高精度加法模板"><a href="#高精度加法模板" class="headerlink" title="高精度加法模板"></a>高精度加法模板</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//总结：</span><span class="hljs-comment">//第一步：字符串输入</span><span class="hljs-comment">//第二步：字符串转数字，逆序</span><span class="hljs-comment">//第三步：模板相加；</span><span class="hljs-comment">//第四步：逆序输出</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><span class="hljs-function"></span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; C;    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);        t/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string a,b;    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//123456</span>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//[6,5,4,3,2,1]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="高精度减法模板"><a href="#高精度减法模板" class="headerlink" title="高精度减法模板"></a>高精度减法模板</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//第一步：输入</span><span class="hljs-comment">//第二步：比较</span><span class="hljs-comment">//第三步：相减：注意括号和前缀0要去掉</span><span class="hljs-comment">//第四步：输出</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)             <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><span class="hljs-function"></span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt;C;    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t=A[i]-t;        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t-=B[i];        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//虽然A比B大，但是A的某一位的数字可能比B小，所以这里加上10再模10</span>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;<span class="hljs-comment">//用于给A去减掉</span>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string a,b;    vector&lt;<span class="hljs-type">int</span>&gt; A,B;    cin&gt;&gt;a&gt;&gt;b;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);    vector&lt;<span class="hljs-type">int</span>&gt;C;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B)) C=<span class="hljs-built_in">sub</span>(A,B);    <span class="hljs-keyword">else</span> C=<span class="hljs-built_in">sub</span>(B,A),cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;<span class="hljs-comment">//这里的负号是A-B=-(B-A)；</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);    cout&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><h4 id="高精度乘法模板"><a href="#高精度乘法模板" class="headerlink" title="高精度乘法模板"></a>高精度乘法模板</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span> </span>&#123;    <span class="hljs-comment">// A: 4 3 2 1</span>    <span class="hljs-comment">// B: 6 5</span>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(max(A.size(), B.size()) + <span class="hljs-number">7</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 数组C开大一点没事，反正可以去前导零的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) C[i] += A[i];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; B.<span class="hljs-built_in">size</span>(); i ++) C[i] += B[i];    <span class="hljs-comment">// 处理进位</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; C.<span class="hljs-built_in">size</span>(); i ++) &#123;        C[i + <span class="hljs-number">1</span>] += C[i] / <span class="hljs-number">10</span>;        C[i] %= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-comment">// 处理前导零</span>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span> </span>&#123;    <span class="hljs-comment">// A: 4 3 2 1</span>    <span class="hljs-comment">// B: 6 5</span>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(A.size() + B.size() + <span class="hljs-number">7</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 数组C开大一点没事，反正可以去前导零的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j ++) &#123;            C[i + j] += A[i] * B[j];        &#125;    &#125;    <span class="hljs-comment">// 处理进位</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; C.<span class="hljs-built_in">size</span>(); i ++) &#123;        C[i + <span class="hljs-number">1</span>] += C[i] / <span class="hljs-number">10</span>;        C[i] %= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-comment">// 处理前导零 &quot;0000&quot; 去掉前导零</span>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    string s1 = <span class="hljs-string">&quot;9899&quot;</span>, s2 = <span class="hljs-string">&quot;100&quot;</span>;    vector&lt;<span class="hljs-type">int</span>&gt; A, B;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) B.<span class="hljs-built_in">push_back</span>(s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>);    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">add</span>(A, B);    cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;+&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&quot;=&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i ++) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    C = <span class="hljs-built_in">mul</span>(A, B);    cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;*&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&quot;=&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i ++) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;链接：https:<span class="hljs-comment">//www.acwing.com/solution/content/13694/</span></code></pre><h4 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//int r=0;</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> B,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<span class="hljs-comment">//r传入r的地址，便于直接对余数r进行修改</span>    vector&lt;<span class="hljs-type">int</span>&gt; C;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">//对A从最高位开始处理</span>        r=r*<span class="hljs-number">10</span>+A[i];<span class="hljs-comment">//将上次的余数*10在加上当前位的数字，便是该位需要除的被除数</span>        C.<span class="hljs-built_in">push_back</span>(r/B);<span class="hljs-comment">//所得即为商在这一位的数字</span>        r=r%B;<span class="hljs-comment">//这里的余数是一个等价关系，不懂可以看视频</span>    &#125;    <span class="hljs-comment">//由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字pop_back是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，</span>    <span class="hljs-comment">//因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0</span>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    string a;    <span class="hljs-type">int</span> B,r=<span class="hljs-number">0</span>; <span class="hljs-comment">//代表余数</span>    cin&gt;&gt;a&gt;&gt;B;    vector&lt;<span class="hljs-type">int</span>&gt; A;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//注意这次的A是由高为传输至低位，由于在除法的手算过程中，发现从高位进行处理</span>    <span class="hljs-comment">//for(int i=0;i&lt;A.size();i++) cout&lt;&lt;A[i];</span>    <span class="hljs-comment">//cout&lt;&lt;B;</span>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A,B,r);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<span class="hljs-comment">//将C从最高位传给最低位</span>    cout&lt;&lt;endl&lt;&lt;r;<span class="hljs-comment">//输出余数</span>    cout&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><pre><code class="hljs C++"><span class="hljs-comment">//前缀和的思想是存sum，然后相减进行计算</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> a[N],sum[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n,m,x;    cin&gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;x;        sum[i]=x+sum[i<span class="hljs-number">-1</span>];    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-type">int</span> l,r;        cin&gt;&gt;l&gt;&gt;r;        cout&lt;&lt;sum[r]-sum[l<span class="hljs-number">-1</span>]&lt;&lt;endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="一维差分模板"><a href="#一维差分模板" class="headerlink" title="一维差分模板"></a>一维差分模板</h4><pre><code class="hljs C++"><span class="hljs-comment">//差分非常高效的减少了运算关系的时间复杂度，二维差分的模板同样可以看y总给的那个矩阵</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> a[N],b[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;l,<span class="hljs-type">int</span> &amp;r,<span class="hljs-type">int</span> &amp;c)</span></span><span class="hljs-function"></span>&#123;    b[l]+=c;    b[r+<span class="hljs-number">1</span>]-=c;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">insert</span>(i,i,a[i]);        <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-type">int</span> l,r,c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r,&amp;c);        <span class="hljs-built_in">insert</span>(l,r,c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i ++ ) b[i]+=b[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><h4 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h4><pre><code class="hljs C++"><span class="hljs-comment">//其实这在后面好像是一道dp题目，双指针算法的核心就是用两个指针来解题</span><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> a[N], s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n, r = <span class="hljs-number">0</span>;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++ i)    &#123;        cin &gt;&gt; a[i];        ++ s[a[i]];        <span class="hljs-keyword">while</span> (s[a[i]] &gt; <span class="hljs-number">1</span>) -- s[a[j++]]; <span class="hljs-comment">// 先减次数后右移</span>        r = <span class="hljs-built_in">max</span>(r, i - j + <span class="hljs-number">1</span>) ;    &#125;    cout &lt;&lt; r;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><pre><code class="hljs `C++">//这里主要是了解一个lowbit操作#include&lt;bits/stdc++.h&gt;using namespace std;int  lowbit(int &amp;x)//这个代码的关键是这个函数，每次输出x=的最后一位1;&#123;    return x&amp;-x;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    while (n -- )    &#123;        int x;         cin &gt;&gt; x;        int res=0;        while(x&gt;0) x-=lowbit(x),res++;//每次减去x的最后一位1;直到没有1，那么res即为所求        cout &lt;&lt; res&lt;&lt;&quot; &quot;;    &#125;    &#125;</code></pre><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><pre><code class="hljs C++"><span class="hljs-comment">//当空间稀疏性非常大的时候的做法，最后的实现也是前缀和，通过离散化，将空间的利用率降低了</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300010</span>; <span class="hljs-comment">//n次插入和m次查询相关数据量的上界</span><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[N];<span class="hljs-comment">//存储坐标插入的值</span><span class="hljs-type">int</span> s[N];<span class="hljs-comment">//存储数组a的前缀和</span>vector&lt;<span class="hljs-type">int</span>&gt; alls;  <span class="hljs-comment">//存储（所有与插入和查询有关的）坐标</span>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; add, query; <span class="hljs-comment">//存储插入和询问操作的数据</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">//返回的是输入的坐标的离散化下标</span>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (l &lt; r) &#123;        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-type">int</span> x, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;c);        add.<span class="hljs-built_in">push_back</span>(&#123;x, c&#125;);        alls.<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-type">int</span> l , r;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);        query.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);        alls.<span class="hljs-built_in">push_back</span>(l);        alls.<span class="hljs-built_in">push_back</span>(r);    &#125;   <span class="hljs-comment">//排序，去重</span>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>());    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">//执行前n次插入操作</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : add) &#123;        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(item.first);        a[x] += item.second;    &#125;    <span class="hljs-comment">//前缀和</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= alls.<span class="hljs-built_in">size</span>(); i++) s[i] = s[i<span class="hljs-number">-1</span>] + a[i];    <span class="hljs-comment">//处理后m次询问操作</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : query) &#123;        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(item.first);        <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(item.second);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[r] - s[l<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><pre><code class="hljs C++">这里看到一个区间合并，很绝的思路模板<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;PII a[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin&gt;&gt;n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i].first,&amp;a[i].second);    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-comment">//sort对于二元组的排序规则是先考虑第一个元素，再考虑第二个元素</span>    <span class="hljs-type">int</span> ed=a[<span class="hljs-number">1</span>].second,ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(ed&gt;=a[i].first)ed=<span class="hljs-built_in">max</span>(ed,a[i].second);        <span class="hljs-keyword">else</span> ans++,ed=a[i].second;    &#125;    cout&lt;&lt;ans+<span class="hljs-number">1</span>&lt;&lt;endl;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础算法&quot;&gt;&lt;a href=&quot;#基础算法&quot; class=&quot;headerlink&quot; title=&quot;基础算法&quot;&gt;&lt;/a&gt;基础算法&lt;/h1&gt;&lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h</summary>
      
    
    
    
    <category term="算法基础课" scheme="https://www.imalun.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基础课-1</title>
    <link href="https://www.imalun.com/2023/12/25/Linux%E5%9F%BA%E7%A1%80%E8%AF%BE-1/"/>
    <id>https://www.imalun.com/2023/12/25/Linux%E5%9F%BA%E7%A1%80%E8%AF%BE-1/</id>
    <published>2023-12-25T06:38:26.795Z</published>
    <updated>2023-12-25T06:38:58.316Z</updated>
    
    
    
    
    <category term="Linux基础" scheme="https://www.imalun.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>新思科技EDA软件开发要求</title>
    <link href="https://www.imalun.com/2023/12/18/%E5%B7%A5%E4%BD%9C%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82/"/>
    <id>https://www.imalun.com/2023/12/18/%E5%B7%A5%E4%BD%9C%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82/</id>
    <published>2023-12-18T15:35:44.841Z</published>
    <updated>2023-12-26T06:37:28.806Z</updated>
    
    <content type="html"><![CDATA[<p>这里他提到了多种语言，说明他对语言的要求是很高的，所以需要抓紧时间熟悉语言并熟练运用</p><p>职位描述:</p><p>平台验证工程师负责验证业界领先的SOC实现工具和流程解决方案，如“IC Compiler II”，“Design Compiler”，formal和下一代数字平台“Fusion Compiler”等。</p><p>·了解客户需求，基于数字化设计流程验证新特性，包括先进节点、5nm、3nm等新特性。</p><p>·验证Synopsys前端/后端流程，跟踪前端/后端流程QOR/性能。</p><p>·了解客户使用情况，提出新要求，完善流程解决方案。</p><p>·用Perl、TCL、Python或C/ c++设计和开发测试程序，包括测试工具和自动化测试套件。</p><p>工作要求:</p><p>电子电气、微电子或相关专业硕士，三年工作经验</p><p>·精通ASIC设计流程。包括平面图，综合，P&amp;R, STA等。期望在很少的复习和指导下找出问题的经典解决方案</p><p>·具有团队合作精神和良好的学习能力，对先进技术和设计流程方法论保持热情和兴趣!</p><p>·必须具备较强的沟通和人际交往能力</p><p>·具备良好的中英文口头和书面沟通能力</p><p>·具有以下一个或多个计算机科学领域的知识和经验者优先考虑:</p><p>编程语言(C/ c++， Shell, TCL, Perl, Python等)</p><p>·Unix/Linux操作系统</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里他提到了多种语言，说明他对语言的要求是很高的，所以需要抓紧时间熟悉语言并熟练运用&lt;/p&gt;
&lt;p&gt;职位描述:&lt;/p&gt;
&lt;p&gt;平台验证工程师负责验证业界领先的SOC实现工具和流程解决方案，如“IC Compiler II”，“Design Compiler”，formal和</summary>
      
    
    
    
    <category term="找工作" scheme="https://www.imalun.com/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>日记-11-20</title>
    <link href="https://www.imalun.com/2023/11/20/%E6%97%A5%E8%AE%B011-20/"/>
    <id>https://www.imalun.com/2023/11/20/%E6%97%A5%E8%AE%B011-20/</id>
    <published>2023-11-20T15:13:56.944Z</published>
    <updated>2023-11-20T15:14:12.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h2><p>应该很久没有写日记了，已经忘记上次写日记是哪天了，生活似乎并没有好过点，还是在不断的告诉自己熬过去熬过去中一天天度过，不知道生活什么时候才会有变化，也许我应该时常问自己，邓福星，你有慢慢的变成更好的自己的吗，不知道为什么，我想告诉自己，我确实好像似乎，在慢慢的变好，我的体重慢慢的下去，我慢慢的去护肤，慢慢的健身，慢慢的去体会生活，我想比起之前的一团糟，我觉得我确实有在慢慢变好，我还是有些时候免不了想陶俊余，我在想，是不是每当我脆弱的时候，我就会想有复合的念头，这样的念头是不正确的，也不该有的对吗，我应该习惯自己慢慢的面对这一切，就写到这里吧，得去忙着改代码了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;随想&quot;&gt;&lt;a href=&quot;#随想&quot; class=&quot;headerlink&quot; title=&quot;随想&quot;&gt;&lt;/a&gt;随想&lt;/h2&gt;&lt;p&gt;应该很久没有写日记了，已经忘记上次写日记是哪天了，生活似乎并没有好过点，还是在不断的告诉自己熬过去熬过去中一天天度过，不知道生活什么时候才会</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于时光朋友的反思</title>
    <link href="https://www.imalun.com/2023/10/22/%E9%9A%8F%E6%83%B310-22/"/>
    <id>https://www.imalun.com/2023/10/22/%E9%9A%8F%E6%83%B310-22/</id>
    <published>2023-10-22T14:56:55.787Z</published>
    <updated>2023-10-22T14:56:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>今晚不知道为什么，对于朋友，有很多很多的感触，我觉得应该都要好好珍惜，人生在世，认识谁都特别不容易，我们要尊重并祝福每个人，每个身边人，少点戾气，多点包容和宽容，珍惜正在发生和将要发生的一起，邓福星，要脾气好点哦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今晚不知道为什么，对于朋友，有很多很多的感触，我觉得应该都要好好珍惜，人生在世，认识谁都特别不容易，我们要尊重并祝福每个人，每个身边人，少点戾气，多点包容和宽容，珍惜正在发生和将要发生的一起，邓福星，要脾气好点哦&lt;/p&gt;
</summary>
      
    
    
    
    <category term="随笔" scheme="https://www.imalun.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>关于论文的反思</title>
    <link href="https://www.imalun.com/2023/10/19/%E9%9A%8F%E6%83%B310-19/"/>
    <id>https://www.imalun.com/2023/10/19/%E9%9A%8F%E6%83%B310-19/</id>
    <published>2023-10-19T10:14:20.456Z</published>
    <updated>2023-10-19T10:14:26.190Z</updated>
    
    <content type="html"><![CDATA[<p>时间过得真快，上一次写文章还是半个月之前了，今天写文章是因为一件事情，也就是跟随师姐们写论文的事情，这件事情让我有些困扰，今天吃饭的时候，一航问我，为什么最近李靖不找我了，其实我想，李靖不找我已经很久了，写这篇文章是想总结一下我心里的想法，就是，我希望李靖找我吗，如果她找了我，并且我认真且热情的回应了她，并且很沉浸进去的和她一起写论文，我想也许我能得到一个论文的二作，并且也许有可能接手李靖的课题，我想我此刻惋惜的也许也是这个，看着大家都有了不错的成绩，都有机会发论文带上名字，我想我心里是很羡慕的，又或者说，我嫉妒?，其实内心里有一点点涉及父母，我不知道我为什么会涉及到父母，也许发篇论文是一件很关键的事情。也许我希望他们的儿子有所成就，也许我心里也想不落后于别人，我想问邓福星，你很想要这个论文作者吗，我想答案是No,没有很想，只是不希望落后与别人，那我要去争取吗，我想我不想去争取，对我来说，这些事情，我看的并不是很重要，至少现在是这样的，我要为了将来的事情去提前做准备吗，为了将来读博的可能性去再争取一下吗，我想不是的，我不想去，是的，我不想去。也许李靖师姐已经很主动了，她对我应该有些失望，但是我不想，是的，我觉得我心力交瘁，我也不知道我追求什么，但我知道的是，我并不是很想再重新参与进去了，我衷心祝愿每个同门有个好结果，可我不应该去进行比较了，我只要过好自己的生活，过好自己的每一天就好了，以后的时间很长，我不去想以后的事，我也不关心别人的想法，我要照顾好我自己，好好的对待我自己，什么狗屁学术，什么狗屁追求，命定的一切终有安排，一切都是外物，把自己过好就可以了。把自己过好就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间过得真快，上一次写文章还是半个月之前了，今天写文章是因为一件事情，也就是跟随师姐们写论文的事情，这件事情让我有些困扰，今天吃饭的时候，一航问我，为什么最近李靖不找我了，其实我想，李靖不找我已经很久了，写这篇文章是想总结一下我心里的想法，就是，我希望李靖找我吗，如果她找了</summary>
      
    
    
    
    <category term="随笔" scheme="https://www.imalun.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>日记-10-2</title>
    <link href="https://www.imalun.com/2023/10/02/%E6%97%A5%E8%AE%B010.2/"/>
    <id>https://www.imalun.com/2023/10/02/%E6%97%A5%E8%AE%B010.2/</id>
    <published>2023-10-02T04:49:46.243Z</published>
    <updated>2023-10-02T04:49:46.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>心里有一件比较不舒服的事情，想写下来，并且刨析我自己，今天是校庆70周年，学校是提供免费午餐的，之前是去登记过了，但是今天去吃饭的时候，阿姨问我有没有餐券我才想起来，我就说今天好多人在三食堂吃饭，于是这段饭我花了20多块，让我本就不富裕的生活学上加霜，我心里开始责怪戴闻浩，我责怪他没有通知我去哪里领餐券，并且为自己没有赚到学校的这个便宜而不开心，心中始终觉得不快，所以我决定对这件事情进行复盘</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>  事件真的是戴闻浩的错吗，学校传达了通知他没有及时告知吗，又或者也许学校没有传达，我想我不该责怪，但我可以问一下，当然，只是询问而已，第二个，当时在阿姨问我有没有餐券的时候，我想我是可以当时去问餐券这个事情，但是我是吃饭的时候才想起来之前登记了免费的午餐，在付钱的时候，我的选择是不进行探究，付了这笔钱，我想是因为我发现我点的餐达到了21.5，所以我心里才不开心吧，所以这是我自己犯的错误，我有机会补救，但我没有，是我自己选择了付钱，不能把问题推到别人身上，也许，我是推卸自己的责任罢了，是的，一切事情都不能指望别人事事靠谱，也不能因为别人没有完善职责，而让自己心里不快，因为事件上什么事情都是可能发生的，愤怒不是合理的，甚至于他不该存在，又或者说，他不该轻易发生，刚闻浩回了微信，说是他这里还有餐券，我想这件事情他也有通知不到位的地方吧，嗯，我觉得这件事情，大部分都是他的问题，他没有履行到他的职责，因为学校方面把这件事情交给了班长。也就是说，即使我当时犹豫了，在付钱之前去问他餐券的事情，我也需要跑去主楼B410问他，对我来说，我可能宁愿花点钱买饭，毕竟也是我自己吃的，算不上冤枉钱。没有必要为这种事情责怪自己，或者感觉心里不痛快，人不患穷，患不均是这样的。人生值得关注的事情真的很少，要关注每一个瞬间，这件事情是一件很小的事情啦，需要修行的地方还很多，所以不要在为这种小事情困扰自己，错误已经造成，又或者说失误已经造成，就没有必要花很多时间去追求失误，去追究责任，尤其是，你没有足够的能力，结果只能是浪费时间而且内耗。但是你可以更清楚地认识一个人是什么样的，了解一个人的做事风格是什么样的，知道一个人靠不靠谱，这样将来可以避免更大的错误，做一个不评论的观察者，是一个很需要智慧的事情</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h1&gt;&lt;p&gt;心里有一件比较不舒服的事情，想写下来，并且刨析我自己，今天是校庆70周年，学校是提供免费午餐的，之前是去登记过了，但是今天去吃饭的时候，阿姨</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>日记-9-16</title>
    <link href="https://www.imalun.com/2023/09/16/%E6%97%A5%E8%AE%B09.16/"/>
    <id>https://www.imalun.com/2023/09/16/%E6%97%A5%E8%AE%B09.16/</id>
    <published>2023-09-16T14:40:02.856Z</published>
    <updated>2023-09-16T14:41:12.668Z</updated>
    
    <content type="html"><![CDATA[<p>最近很久没写日记了，也是因为最近在伤愈之中，只从小号被一句话不留的删掉之后，好不容易缝起来的自己，好像啪的一下又碎掉了，今天写日记主要是为了纪念一个小小的感动，也浅浅描述一下最近发生的事情</p><h2 id="感动"><a href="#感动" class="headerlink" title="感动"></a>感动</h2><p>因为上课的路途很远的问题，宿舍里只有我一个人是走路去，其实我觉得没什么，张津豪，我的室友，是一个很机灵也很善于打探消息的一个人，学校每年都会收捡毕业生遗留未带走的单车，然后收集起来，通过一个考试，按成绩排名，发放给学生，我的室友，他已经有一部单车了，他还专门去考试，它拿到了，而我排名落后没有拿到，结果今晚他说，明天领车了，要把那部车送给我，因为我没有车，唉，着实有点感动，挺谢谢的吧</p><h2 id="琐事"><a href="#琐事" class="headerlink" title="琐事"></a>琐事</h2><p>最近申请了贫困补助，是b类，就是家庭困难级别，不知道有没有钱，有多少钱</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近很久没写日记了，也是因为最近在伤愈之中，只从小号被一句话不留的删掉之后，好不容易缝起来的自己，好像啪的一下又碎掉了，今天写日记主要是为了纪念一个小小的感动，也浅浅描述一下最近发生的事情&lt;/p&gt;
&lt;h2 id=&quot;感动&quot;&gt;&lt;a href=&quot;#感动&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>告别语</title>
    <link href="https://www.imalun.com/2023/08/29/%E5%91%8A%E5%88%AB%E8%AF%AD/"/>
    <id>https://www.imalun.com/2023/08/29/%E5%91%8A%E5%88%AB%E8%AF%AD/</id>
    <published>2023-08-29T09:35:04.890Z</published>
    <updated>2023-12-30T12:10:47.218Z</updated>
    
    <content type="html"><![CDATA[<p>还是想好好告个别，源于我五年前听的两个小故事，我原封不动的搬回来</p><h1 id="故事一"><a href="#故事一" class="headerlink" title="故事一"></a>故事一</h1><p>大家晚上好，这里是就服秘书处深夜电台第三期，还是我杨杨。<br>时间好快，这一年对于一八级的孩子们而言，经历了太多太多。上半年的大家还在高中为高考而殚精竭虑，下半年迢迢而至来到雅西川农。或许，你们很多人只是之身而来，把太多太多留在了过去。今晚，杨杨给大家带来的是一个故事。虽不扣人心弦，但是值得我们每一个人去思考，去感受。这个故事的名字叫做《章台柳》。<br>唐朝玄宗皇帝年间，有一个才子叫作韩翊（yi第四声）。韩翊年少有才考中进士，回乡省亲时与同乡佳人柳氏结为连理，二人情投意合相爱至深。不久，韩翊走马上任，需要背井离乡去淄青节度使账下做官。路途遥远且官资尚浅，韩翊不便带上爱妻，只能让柳氏独守家中相约日后夫君锦衣归来。<br>可是，韩翊上任不久后，安史之乱爆发。叛军气势汹汹占领了大片城池，其中就包括韩翊的家乡。柳氏没能等到韩翊的归来，只能自己东躲西藏。因为柳氏姿容美艳而又没有丈夫在身边保护，乱世之中总被人骚扰。她怕自己的美艳惹祸哪天被人玷污，不能还韩翊玉洁之身，便剪断一头乌发，自毁容颜，躲避于僻静的山寺之中，晨钟暮鼓，只盼夫君韩翊早日到来。<br>后来，安史之乱平息。韩翊官升数级，进入朝堂。他派人回乡打听妻子柳氏的下落。这时的韩翊却生了鸡肠之心。他写了一封信给手下带回家乡寻柳氏。心里写道“章台柳，章台柳，昔日青青今在否？纵使长条似旧垂，亦应攀折他人手。”意思很明了，韩翊质问柳氏，你如此美貌又过了那么多年，肯定攀附别人去了。<br>手下带着这封信回到了韩翊故乡，找到了妻子柳氏。柳氏看完韩翊的信后心灰意冷，可怜自己为他做的一切。柳氏回信给韩翊，信里写道“杨柳枝，芳菲节。所很年年赠离别，一叶随风忽报秋，纵使君来不堪折。”意思别是，自己纵然是一颗婀娜的杨柳，但是如今也是秋过枯黄，即便是你回来也不愿再回顾这棵曾经的柳了。柳氏不诉说自己的委屈，只是对韩翊死心了。<br>可这封书信还没能送到韩翊手中。外番将军沙吒利路过韩翊家乡看到了柳氏，大为心动，便把柳氏抢占为己有。柳氏便这样被沙吒利带回了长安，沙吒利对柳氏还算好，柳氏也成了将军的宠妾。可这事传到了同样在长安的韩翊耳中，韩翊大为震惊。一天宴席中韩翊的好友发觉韩翊心事重重便询问他。韩翊把柳氏的事情告诉了好友，好友听后决心替韩翊抢回柳氏。于是立刻骑马跑到沙吒利府上，正好沙将军外出，他便以沙吒利遇害将死想见柳氏最后一眼为理由接到了柳氏，马上把柳氏带到韩翊府中。韩柳二人终得相逢，柳氏把这些年来自己的遭遇一一告诉了韩翊，韩翊自责不已。后来，韩翊在自己老上级的帮助下从沙吒利手中赎回来柳氏，一对苦命鸳鸯终得重逢。从此过上了幸福快乐的生活。<br>每个故事都有属于读者自己的领会，希望大家能在这个深夜静静地看完故事，日后不要负了你的章台柳。</p><h1 id="故事二"><a href="#故事二" class="headerlink" title="故事二"></a>故事二</h1><p>大概是五六年前，也是在川农，有一对师兄师姐，他们高中就是同学，后来不约而同地上了川农，可能是他乡遇故知的亲切感使然吧，他们大一就耍朋友了，这段情感绵绵到了大四，俩人都选择了考研互相鼓励，而且俩人成绩都不错，以前做了很多实践科研什么的，简直一对璧人。五六年前的那次考研结束后，可能是此间真情天也妒吧。师兄上了川大的研究生，师姐经过调剂又复试后没过，上不了研。可能是师姐家庭条件的原因她不能选择二战，于是师姐选择了回去家乡考公务员。此时二人许诺四年了，这段情不会因为三年的殊途而变故。毕业后的那个暑假他们一起去了西藏，看了圣洁的布达拉宫，一起走了文成公主曾经来过的路。<br>后来开学了，师兄去了川大。师姐回了他们的家乡备考公务员。每天都会相互问候，每周末师兄都会回家见面。这一年师姐考上了家乡的公务员，做了一个区政府的科员。研二以后师兄越来越忙，因为专业的需要师兄和导师去了云南西双版纳，师兄忙碌的科研生活无法再抽时间和师姐通讯交流。这时的师姐被家里人催婚了，因为师姐有稳定工作稳定收入，父母担心就是成家了。师姐告诉父母她和师兄有约，师兄毕业后他们才谈婚论嫁。尽管这时候师兄师姐已经大半年没好好联系了。<br>那一年师兄研三，在准备毕业了。那一年师姐结婚了，新郎是师姐区政府的同事，这三年来一直在单位体贴照顾师姐的一个好男人。<br>师兄川大硕士研究生毕业后没有再去找师姐也没有回家，而是去以色列进修了。曾经的一对璧人，五六年后，造物告诉他们，青春很美，因为那是一副画，也是一场梦。</p><p>但是现在的他们都很幸福，师兄在进步，师姐也有了好归属。就是这么看都觉得有点遗憾</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;还是想好好告个别，源于我五年前听的两个小故事，我原封不动的搬回来&lt;/p&gt;
&lt;h1 id=&quot;故事一&quot;&gt;&lt;a href=&quot;#故事一&quot; class=&quot;headerlink&quot; title=&quot;故事一&quot;&gt;&lt;/a&gt;故事一&lt;/h1&gt;&lt;p&gt;大家晚上好，这里是就服秘书处深夜电台第三期，还是我杨</summary>
      
    
    
    
    <category term="随笔" scheme="https://www.imalun.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>日记 8-27</title>
    <link href="https://www.imalun.com/2023/08/27/%E6%97%A5%E8%AE%B08-27/"/>
    <id>https://www.imalun.com/2023/08/27/%E6%97%A5%E8%AE%B08-27/</id>
    <published>2023-08-27T14:52:27.014Z</published>
    <updated>2023-08-27T14:52:43.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天想了一些乱七八糟的，不切实际的，大概就是陶俊余也想找我复合吧，但有什么迫不得已的原因，仔细想想，白日做梦罢了，总是有这些不切实际的幻想，对了，来学校一周了，每天的内裤和袜子都每天洗，虽然有什么很累，但还是爬起来洗了，好想告诉他，我正在慢慢的该这些坏习惯，也很久没说他妈的了，唉，可惜再也回不去了</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今天主打就是一个摆烂，什么也没做，难得没有什么事，休息了一天</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>没什么反思，适当的摆烂是必要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;情感&quot;&gt;&lt;a href=&quot;#情感&quot; class=&quot;headerlink&quot; title=&quot;情感&quot;&gt;&lt;/a&gt;情感&lt;/h1&gt;&lt;p&gt;今天想了一些乱七八糟的，不切实际的，大概就是陶俊余也想找我复合吧，但有什么迫不得已的原因，仔细想想，白日做梦罢了，总是有这些不切实际的幻想，</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>今日的一些思考-8-26</title>
    <link href="https://www.imalun.com/2023/08/26/%E6%97%A5%E8%AE%B08-26/"/>
    <id>https://www.imalun.com/2023/08/26/%E6%97%A5%E8%AE%B08-26/</id>
    <published>2023-08-26T15:07:33.801Z</published>
    <updated>2023-08-26T15:07:37.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天中午想到了一些事情，自己也感同深受了一番，觉得过去对陶俊余说过的很多话都带有指责逼问的意思，虽然那个时候我自己并没有意识到，或者意识到了，但是面对陶俊余的妥协和忍让，让我觉得这不是什么大不了的事情，一直没有重视这个问题，以至于长期以来甚至对她说的不要骂我，以及害怕我感到很不解，但是今天我终于懂了，因为我自己也经历了一番，觉得真的是一件很委屈很委屈的事情，一想到过去自己对陶俊余那么不好，情绪又崩溃了，一直哭一直哭，中午在路上的时候忍住眼泪没掉下来，回来宿舍之后，躺在床上忍不住的嚎啕大哭，把眼睛都哭肿了，现在哭的眼睛还疼，很想给她发消息说对不起什么的，但是我想现在好像正是秋招的关键时期，不要打扰她的比较好，我所能为她做的，最大的事情，大概就是不打扰她吧，真心希望她能找到一个好男人，不要再碰到我这种垃圾了，真心真心希望她幸福，其实我才是那个最自我的人</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今天戴闻浩的语气让我很不爽，以后跟这人少接触吧，戾气太重了，今天是摆烂的一天，什么事情也做不进去</p><h1 id="今日反思"><a href="#今日反思" class="headerlink" title="今日反思"></a>今日反思</h1><p>以后如果生气了想说什么话，一定不要说，要忍者，因为通常你生气的时候说出的话，事后你会觉得很后悔</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;情感&quot;&gt;&lt;a href=&quot;#情感&quot; class=&quot;headerlink&quot; title=&quot;情感&quot;&gt;&lt;/a&gt;情感&lt;/h1&gt;&lt;p&gt;今天中午想到了一些事情，自己也感同深受了一番，觉得过去对陶俊余说过的很多话都带有指责逼问的意思，虽然那个时候我自己并没有意识到，或者意识到了</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>今日的一些思考-8-25</title>
    <link href="https://www.imalun.com/2023/08/25/%E6%97%A5%E8%AE%B08-25/"/>
    <id>https://www.imalun.com/2023/08/25/%E6%97%A5%E8%AE%B08-25/</id>
    <published>2023-08-25T15:28:19.678Z</published>
    <updated>2023-08-25T15:28:25.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天发现原来今天才8月25号，20号给陶俊余发消息没有回复以后，每一天都过得很艰难也很漫长，让我以为时间已经过去了很久，原来也才5天，对于感情的想法是，也许我不值得拥有感情，也不该再去耽误别人，我想我是一个很差劲的人</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今天早上是开学典礼，开了一会我就走了，后来去了图书馆，因为暑假的作业一直没写，老师又一直催，所以去图书管写作业，但是那个代码对我来说太难了，今天一天把我头都给想大了，大脑实在是不能继续运转，下午四点多的时候，实在是精神不能再聚焦，于是我回宿舍，爬到床上，很快的睡了一个多小时，工科读研感觉真的挺难的，中午吃饭和师兄聊天，才知道原来就业形势并没有那么好，真正的了解到了什么是大饼，但是我本就一开始就没有选择，今后要抓紧自学，把时间都利用起来，我想三年，应该最后能找个还行的工作，一定要努力学习，把时间把握在自己的手中，睡完觉之后就去图书馆看了会代码，很快就写出来了，成功的原因在于下午睡觉之前和朋友交流了一下，所以说交流时很有必要的，向成功的人交流</p><h1 id="今日反思"><a href="#今日反思" class="headerlink" title="今日反思"></a>今日反思</h1><p>今天才又一次意识到应该抓紧时间自学，一丁点时间也不能再继续浪费了，为了找个好工作，不要再重蹈本科的覆辙了。收获在于知道了如果你很累，那就去休息，但不是玩手机，休息完之后也许一切就茅塞顿开了，最近博客上传照片总是失败，找个时间研究一下，最近太忙了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;情感&quot;&gt;&lt;a href=&quot;#情感&quot; class=&quot;headerlink&quot; title=&quot;情感&quot;&gt;&lt;/a&gt;情感&lt;/h1&gt;&lt;p&gt;今天发现原来今天才8月25号，20号给陶俊余发消息没有回复以后，每一天都过得很艰难也很漫长，让我以为时间已经过去了很久，原来也才5天，对于感</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>今日的一些思考-8-24</title>
    <link href="https://www.imalun.com/2023/08/24/%E6%97%A5%E8%AE%B08-24/"/>
    <id>https://www.imalun.com/2023/08/24/%E6%97%A5%E8%AE%B08-24/</id>
    <published>2023-08-24T14:46:05.674Z</published>
    <updated>2023-08-25T15:28:30.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>昨天没有写日记，其实昨天想写的东西还挺多的，那一会懒得开电脑了所以没有记录，今天把还记得得一起写下来，昨天导师让我们去城里参加一个会，risc-v中国区峰会。本来报名时间都过了，因为导师是汇报人员，也就是大佬，没报名也让我们去了，但其实大家是不想去得，峰会在北京香格里拉饭店，在城里，坐地铁要一个多小时，但是导师说要一起拍照合照，于是我们六点起床，我和另外四个同学打了一个六座得商务座去了北京，每人60，宿舍有一个叫段永强得，已经几天没回宿舍睡了，他的女朋友为了他。来昌平找工作了，他们在昌平租了个房子，我问了下价格800，说实话我很羡慕他们那个时候，但是我忘记了我羡慕得是啥了，但那一刻我心里满是陶俊余，这就是昨天得情感故事了，今天我突然想起，我和她第一次分手得时候，我问她还我2000块钱，还发短信骂她，这真的是一件非常过分得事情呀，可是我直到今天才意识到这件事情真的很过分，我想也许我才是一个自我的人，我沉浸在自我的世界和忙于保护自我，其实她早已被我伤害得体无完肤，我那样得过分，她还愿意和我复合，我想其实她是想和我走下去得，至少曾经是这样的，我时常害怕自己是唯一一个还困在原地得人，可我不得不去面对我心里得很多很多得放不下得事情和突然涌上得回忆，我还对她有诸多得欺骗和隐瞒，她以前说的没错，她确实是一个吸渣体制，谈的都是渣男，今天晚上坐在图书馆刷抖音得时候，刷到重庆火锅一度还落下泪来，觉得其实自己也受了好多委屈，去成都两个月其实也没吃啥好的，连自己很喜欢吃的烧烤一次都没去吃过，只在那个巷子门口那个烧烤摊吃过，最后一次想好好吃个烧烤，结果因为说错话，在大庭广众之下被吼，最后也没好好吃，其实觉得自己也受了挺多委屈得，到了成都疯狂得找工作，试工作，每天两个小时得通勤，其实也没过什么好日子，如果不是为了爱情，我在家里怎么需要受这样得苦，唉，现在回想起来觉得自己挺矫情得，和我分手是对的，分手之后，其实我一直陷入一种自我怀疑当中，觉得自己很差劲很差劲，现在想着确实很差劲很差劲，简直就是垃圾，毒瘤，离开我是对的，我这种人不值得留恋</p><h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><p>生活今天早上开研究生新生教育会，下去去实验室和师姐讨论课题，实验室太闷了，我实在呆不下去，转战到图书馆，今天一点学习得心情都没有，头晕呼呼得，不想动脑子，在图书馆一直刷抖音吃播，好像就是这么平平无奇得一天</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;情感&quot;&gt;&lt;a href=&quot;#情感&quot; class=&quot;headerlink&quot; title=&quot;情感&quot;&gt;&lt;/a&gt;情感&lt;/h1&gt;&lt;p&gt;昨天没有写日记，其实昨天想写的东西还挺多的，那一会懒得开电脑了所以没有记录，今天把还记得得一起写下来，昨天导师让我们去城里参加一个会，ris</summary>
      
    
    
    
    <category term="日记" scheme="https://www.imalun.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
